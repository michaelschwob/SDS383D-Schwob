t(Y.m[1,]-mu.m)%*%(Y.m[1,]-mu.m)
pi_ik=c(1,2,3)
r=0
if(sum(pi_ik)){
r=1
}
library(mclust)
library(datasets)
data = faithful
data
out=Mclust(data,G=3)
out$BIC
library(ggplot2)
??geom_density_2d_filled
dbinom(1,1,.3)
dbinom(0,1,.3)
install.packages("rstudioapi")
install.packages(c("car", "corrplot", "cpp11", "crosstalk", "glue", "mclust", "nloptr", "RcppArmadillo", "tibble", "tinytex", "xfun"))
Synthwave85 <- "https://raw.githubusercontent.com/jnolis/synthwave85/master/Synthwave85.rstheme"
rstudioapi::addTheme(Synthwave85, apply = TRUE)
oceanic_theme <- "https://raw.githubusercontent.com/gadenbuie/oceanic-eighties/master/oceanic-eighties.rstheme"
rstudioapi::addTheme(oceanic_theme, apply = TRUE)
driven_snow <- "https://raw.githubusercontent.com/mkearney/driven-snow/master/theme/driven-snow.rstheme"
rstudioapi::addTheme(driven_snow, apply = TRUE)
ayu_light_owl <- "https://raw.githubusercontent.com/js-oh/ayu-light-owl/master/ayu-light-owl.rstheme"
rstudioapi::addTheme(ayu_light_owl, apply = TRUE)
my_theme <- "https://raw.githubusercontent.com/brunaw/my-theme/master/my-theme.rstheme"
rstudioapi::addTheme(my_theme, apply = TRUE)
night_owlish <- "https://raw.githubusercontent.com/batpigandme/night-owlish/master/rstheme/night-owlish.rstheme"
rstudioapi::addTheme(night_owlish, apply = TRUE)
yule_theme <- "https://raw.githubusercontent.com/gadenbuie/yule-rstudio/master/Yule-RStudio.rstheme"
rstudioapi::addTheme(yule_theme, apply = TRUE)
t=3 # number of groups
Nt=c(14,15,13) # number of observations in each group
c1=c(rep(1,N1),rep(0,N2),rep(0,N3))
c1=c(rep(0,N1),rep(1,N2),rep(0,N3))
c1=c(rep(0,N1),rep(0,N2),rep(1,N3))
X=cbind(c1,c2,c3)
t=3 # number of groups
Nt=c(14,15,13) # number of observations in each group
N1=Nt[1]
N2=Nt[2]
N3=Nt[3]
c1=c(rep(1,N1),rep(0,N2),rep(0,N3))
c1=c(rep(0,N1),rep(1,N2),rep(0,N3))
c1=c(rep(0,N1),rep(0,N2),rep(1,N3))
X=cbind(c1,c2,c3)
t=3 # number of groups
Nt=c(14,15,13) # number of observations in each group
N1=Nt[1]
N2=Nt[2]
N3=Nt[3]
c1=c(rep(1,N1),rep(0,N2),rep(0,N3))
c2=c(rep(0,N1),rep(1,N2),rep(0,N3))
c3=c(rep(0,N1),rep(0,N2),rep(1,N3))
X=cbind(c1,c2,c3)
X
t(X)
t(X)%*%X
solve(t(X)%*%X)
library(MASS)
library(pracma)
fractions(solve(t(X)%*%X))
X%*%solve(t(X)%*%X)
fractions(X%*%solve(t(X)%*%X))
fractions(t(X)%*%solve(t(X)%*%X)%*%t(X))
fractions((X)%*%solve(t(X)%*%X)%*%t(X))
fractions(solve(t(X)%*%X)%*%t(X))
t(X)%*%X
solve(t(X)%*%X)
fractions(solve(t(X)%*%X))
fractions(X%*%solve(t(X)%*%X)%*%t(X))
fractions(X%*%solve(t(X)%*%X))
fractions(X%*%solve(t(X)%*%X)%*%t(X))
fractions(solve(t(X)%*%X)%*%t(X))
getwd()
install.packages("coda")
install.packages("patchwork")
## title: Problem 7
## author: Michael R. Schwob
set.seed(384)
n <- 1000
u.sample <- runif(n, 0, 1)
u.sample
bin.sample <- rbinom(n, 4, 5/8)
bin.sample
pgeom(.3,0.8)
pgeom(.4,0.8)
pgeom(.5,0.8)
pgeom(.7,0.8)
qgeom(.2,0.8)
qgeom(.6,0.8)
1-exp(-0.8*0.2)
## title: Problem 7
## author: Michael R. Schwob
set.seed(384)
n <- 1000
u.sample <- runif(n, 0, 1)
lambda <- 0.8
1-exp(-lambda*0.2)
1-exp(-lambda*3)
dbinom(0.019,4,5/8)
qbinom(0.019,4,5/8)
qbinom(0.021,4,5/8)
qbinom(0.15,4,5/8)
qbinom(0.16,4,5/8)
dbinom(1,4,5/8)
qbinom(1,4,5/8)
pbinom(1,4,5/8)
1-0.2^1
dgeom(1,0.8)
dbinom(2,4,5/8)
pgeom(2,4,5/8)
pbinom(2,4,5/8)
pbinom(0,4,5/8)
pbinom(1,4,5/8)
pbinom(2,4,5/8)
pbinom(3,4,5/8)
pbinom(4,4,5/8)
dgeom(1,0.8)
pgeom(1,0.8)
1-(0.2)^1
pgeom(1,0.8)
pgeom(2,0.8)
pgeom(3,0.8)
pgeom(7,0.8)
pgeom(0,0.8)
pgeom(1,0.8)
pgeom(2,0.8)
pgeom(3,0.8)
pgeom(4,0.8)
pgeom(5,0.8)
pgeom(6,0.8)
pgeom(7,0.8)
matrix(rep(1,3),nrow=3)
matrix(rep(1,3),nrow=3)%*%t(matrix(rep(1,3),nrow=3))
func <- function(k){
result <- (k*gamma(k/2))^2
return(result)
}
func(10)
10!
factorial(k)
func <- function(k){
result <- (k*gamma(k/2))^2
return(result)
}
k <- 10000
func(k)
factorial(k)
func <- function(k){
result <- (k*gamma(k/2))^2
return(result)
}
k <- 100
func(k)
factorial(k)
func <- function(k){
result <- (k*gamma(k/2))^2
return(result)
}
k <- 10
func(k)
factorial(k)
rm(list=ls())
getwd()
ls()
install.packages("devtools")
install.packages("rjags")
####
data <- read.csv("weather.csv",header=T)
library(rmvtnorm)
library(mvtnorm)
####
data <- read.csv("weather.csv",header=T)
####
setwd("/home/mikel/Desktop/Code/SDS383D-Schwob/exercises/Exercise 6")
data <- read.csv("weather.csv",header=T)
####
setwd("/home/mikel/Desktop/Code/SDS383D-Schwob/data")
data <- read.csv("weather.csv",header=T)
y <- data$pressure
# y <- data$temperature
X <- data[,3:4]
n <- length(y)
## Function of Squared exponential covariance function
Exp2Sigma <- function(X, b, tau1sq, tau2sq){
eucDist = as.matrix(dist(X,diag=T,upper=T))
kron.delta = diag(nrow=length(x))
tau1sq*exp(-.5*(eucDist/b)^2) + tau2sq*kron.delta
}
## Function of Squared exponential covariance function
Exp2Sigma_sep <- function(X, b, tau1sq, tau2sq){
Dist1 = as.matrix(dist(X[,1],diag=T,upper=T))
Dist2 = as.matrix(dist(X[,2],diag=T,upper=T))
kron.delta = diag(nrow=nrow(X))
tau1sq*exp(-.5*((Dist1/as.numeric(b[1]))^2+ (Dist2/as.numeric(b[2]))^2)) + tau2sq*kron.delta
}
## Function to calculate the log marginal distribution
logmar <- function(y, X, b, tau1sq, tau2sq){
C <- Exp2Sigma_sep(X, b, tau1sq, tau2sq)
y_mat <- matrix(y,ncol=1)
lp <- -n/2*log(2*pi) - 1/2*log(det(C + sigma2*diag(n))) - 1/2*t(y_mat)%*%solve(C + sigma2*diag(n))%*%y_mat
return(lp)
}
logmar(y,X,0.05,2,0.00001)
logmar(y,X,c(0.05,0.05),2,0.00001)
tau2sq <- 1e-6
sigma2 <- 1
logmar(y,X,c(0.05,0.05),2,0.00001)
## Function to calculate the log marginal distribution
logmar <- function(y, X, b, tau1sq, tau2sq){
C <- Exp2Sigma_sep.new(X, b, tau1sq, tau2sq)
y_mat <- matrix(y,ncol=1)
lp <- -n/2*log(2*pi) - 1/2*log(det(C + sigma2*diag(n))) - 1/2*t(y_mat)%*%solve(C + sigma2*diag(n))%*%y_mat
return(lp)
}
logmar(y,X,c(0.05,0.05),2,0.00001)
Exp2Sigma_sep.new <- function(X, b, tau1sq, tau2sq){
eucDist <- distance(X)
kron.delta = diag(nrow=dim(X)[1])
tau1sq*exp(-.5*(eucDist/b)^2) + tau2sq
}
logmar(y,X,c(0.05,0.05),2,0.00001)
library(plgp)
logmar(y,X,c(0.05,0.05),2,0.00001)
logmar(y,X,0.05,2,0.00001)
library(mvtnorm)
####
setwd("/home/mikel/Desktop/Code/SDS383D-Schwob/data")
data <- read.csv("weather.csv",header=T)
y <- data$pressure
# y <- data$temperature
X <- data[,3:4]
n <- length(y)
## Function of Squared exponential covariance function
Exp2Sigma <- function(X, b, tau1sq, tau2sq){
eucDist = as.matrix(dist(X,diag=T,upper=T))
kron.delta = diag(nrow=length(x))
tau1sq*exp(-.5*(eucDist/b)^2) + tau2sq*kron.delta
}
## Function of Squared exponential covariance function
Exp2Sigma_sep <- function(X, b, tau1sq, tau2sq){
Dist1 = as.matrix(dist(X[,1],diag=T,upper=T))
Dist2 = as.matrix(dist(X[,2],diag=T,upper=T))
kron.delta = diag(nrow=nrow(X))
tau1sq*exp(-.5*((Dist1/as.numeric(b[1]))^2+ (Dist2/as.numeric(b[2]))^2)) + tau2sq*kron.delta
}
## Function to calculate the log marginal distribution
logmar <- function(y, X, b, tau1sq, tau2sq){
C <- Exp2Sigma(X, b, tau1sq, tau2sq)
y_mat <- matrix(y,ncol=1)
lp <- -n/2*log(2*pi) - 1/2*log(det(C + sigma2*diag(n))) - 1/2*t(y_mat)%*%solve(C + sigma2*diag(n))%*%y_mat
return(lp)
}
tau2sq <- 1e-6
sigma2 <- 1
## find optimal parameters
tau1sq_seq <- seq(10,200,length.out = 50)
b1_seq <- seq(0.01,5,length.out = 50)
b2_seq <- seq(0.01,5,length.out = 50)
grid <- expand.grid(tau1sq_seq,b1_seq,b2_seq)
lp <- rep(NA,nrow(grid))
for (i in 1:nrow(grid)){
lp[i] <- logmar(y, X, b = grid[i,2], tau1sq = grid[i,1], tau2sq = 1e-6)
if (i %%100 == 0){cat(i,"\t")}
}
## Function of Squared exponential covariance function
Exp2Sigma <- function(X, b, tau1sq, tau2sq){
eucDist = as.matrix(dist(X,diag=T,upper=T))
kron.delta = diag(nrow=length(X))
tau1sq*exp(-.5*(eucDist/b)^2) + tau2sq*kron.delta
}
## Function of Squared exponential covariance function
Exp2Sigma_sep <- function(X, b, tau1sq, tau2sq){
Dist1 = as.matrix(dist(X[,1],diag=T,upper=T))
Dist2 = as.matrix(dist(X[,2],diag=T,upper=T))
kron.delta = diag(nrow=nrow(X))
tau1sq*exp(-.5*((Dist1/as.numeric(b[1]))^2+ (Dist2/as.numeric(b[2]))^2)) + tau2sq*kron.delta
}
## Function to calculate the log marginal distribution
logmar <- function(y, X, b, tau1sq, tau2sq){
C <- Exp2Sigma(X, b, tau1sq, tau2sq)
y_mat <- matrix(y,ncol=1)
lp <- -n/2*log(2*pi) - 1/2*log(det(C + sigma2*diag(n))) - 1/2*t(y_mat)%*%solve(C + sigma2*diag(n))%*%y_mat
return(lp)
}
tau2sq <- 1e-6
sigma2 <- 1
## find optimal parameters
tau1sq_seq <- seq(10,200,length.out = 50)
b1_seq <- seq(0.01,5,length.out = 50)
b2_seq <- seq(0.01,5,length.out = 50)
grid <- expand.grid(tau1sq_seq,b1_seq,b2_seq)
lp <- rep(NA,nrow(grid))
for (i in 1:nrow(grid)){
lp[i] <- logmar(y, X, b = grid[i,2], tau1sq = grid[i,1], tau2sq = 1e-6)
if (i %%100 == 0){cat(i,"\t")}
}
X
b
b=grid[3,2]
tau1sq=grid[3,1]
tau2sq=1e-6
eucDist = as.matrix(dist(X,diag=T,upper=T))
kron.delta = diag(nrow=length(X))
tau1sq*exp(-.5*(eucDist/b)^2) + tau2sq*kron.delta
tau1sq*exp(-.5*(eucDist/b)^2)
dim(tau1sq*exp(-.5*(eucDist/b)^2))
dim(tau2sq*kron.delta)
library(mvtnorm)
####
setwd("/home/mikel/Desktop/Code/SDS383D-Schwob/data")
data <- read.csv("weather.csv",header=T)
y <- data$pressure
# y <- data$temperature
X <- data[,3:4]
n <- length(y)
## Function of Squared exponential covariance function
Exp2Sigma <- function(X, b, tau1sq, tau2sq){
eucDist = as.matrix(dist(X,diag=T,upper=T))
kron.delta = diag(nrow=X)
tau1sq*exp(-.5*(eucDist/b)^2) + tau2sq*kron.delta
}
## Function of Squared exponential covariance function
Exp2Sigma_sep <- function(X, b, tau1sq, tau2sq){
Dist1 = as.matrix(dist(X[,1],diag=T,upper=T))
Dist2 = as.matrix(dist(X[,2],diag=T,upper=T))
kron.delta = diag(nrow=nrow(X))
tau1sq*exp(-.5*((Dist1/as.numeric(b[1]))^2+ (Dist2/as.numeric(b[2]))^2)) + tau2sq*kron.delta
}
## Function of Squared exponential covariance function
Exp2Sigma <- function(X, b, tau1sq, tau2sq){
eucDist = as.matrix(dist(X,diag=T,upper=T))
kron.delta = diag(nrow(X))
tau1sq*exp(-.5*(eucDist/b)^2) + tau2sq*kron.delta
}
## Function of Squared exponential covariance function
Exp2Sigma_sep <- function(X, b, tau1sq, tau2sq){
Dist1 = as.matrix(dist(X[,1],diag=T,upper=T))
Dist2 = as.matrix(dist(X[,2],diag=T,upper=T))
kron.delta = diag(nrow=nrow(X))
tau1sq*exp(-.5*((Dist1/as.numeric(b[1]))^2+ (Dist2/as.numeric(b[2]))^2)) + tau2sq*kron.delta
}
## Function to calculate the log marginal distribution
logmar <- function(y, X, b, tau1sq, tau2sq){
C <- Exp2Sigma(X, b, tau1sq, tau2sq)
y_mat <- matrix(y,ncol=1)
lp <- -n/2*log(2*pi) - 1/2*log(det(C + sigma2*diag(n))) - 1/2*t(y_mat)%*%solve(C + sigma2*diag(n))%*%y_mat
return(lp)
}
tau2sq <- 1e-6
sigma2 <- 1
## find optimal parameters
tau1sq_seq <- seq(10,200,length.out = 50)
b1_seq <- seq(0.01,5,length.out = 50)
b2_seq <- seq(0.01,5,length.out = 50)
grid <- expand.grid(tau1sq_seq,b1_seq,b2_seq)
lp <- rep(NA,nrow(grid))
for (i in 1:nrow(grid)){
lp[i] <- logmar(y, X, b = grid[i,2], tau1sq = grid[i,1], tau2sq = 1e-6)
if (i %%100 == 0){cat(i,"\t")}
}
function (x, rownames.force = NA, ...)
library(mvtnorm)
####
setwd("/home/mikel/Desktop/Code/SDS383D-Schwob/data")
data <- read.csv("weather.csv",header=T)
y <- data$pressure
# y <- data$temperature
X <- data[,3:4]
n <- length(y)
## Function of Squared exponential covariance function
Exp2Sigma <- function(X, b, tau1sq, tau2sq){
eucDist = as.matrix(dist(X,diag=T,upper=T))
kron.delta = diag(nrow(X))
tau1sq*exp(-.5*(eucDist/b)^2) + tau2sq*kron.delta
}
## Function of Squared exponential covariance function
Exp2Sigma_sep <- function(X, b, tau1sq, tau2sq){
Dist1 = as.matrix(dist(X[,1],diag=T,upper=T))
Dist2 = as.matrix(dist(X[,2],diag=T,upper=T))
kron.delta = diag(nrow=nrow(X))
tau1sq*exp(-.5*((Dist1/as.numeric(b[1]))^2+ (Dist2/as.numeric(b[2]))^2)) + tau2sq*kron.delta
}
# ## Create covariance matrix with Matern function (squared exponential) given distance matrix
# matern.dist <- function(X, b12, tau1sq, tau2sq) {
#   kron.delta = diag(nrow=dim(X)[1])
#   tau1sq*exp(-.5*(X/b)^2) + tau2sq
# }
## Function to calculate the log marginal distribution
logmar <- function(y, X, b, tau1sq, tau2sq){
C <- Exp2Sigma(X, b, tau1sq, tau2sq)
y_mat <- matrix(y,ncol=1)
lp <- -n/2*log(2*pi) - 1/2*log(det(C + sigma2*diag(n))) - 1/2*t(y_mat)%*%solve(C + sigma2*diag(n))%*%y_mat
return(lp)
}
tau2sq <- 1e-6
sigma2 <- 1
## find optimal parameters
tau1sq_seq <- seq(10,200,length.out = 50)
b1_seq <- seq(0.01,5,length.out = 50)
b2_seq <- seq(0.01,5,length.out = 50)
grid <- expand.grid(tau1sq_seq,b1_seq)
lp <- rep(NA,nrow(grid))
for (i in 1:nrow(grid)){
lp[i] <- logmar(y, X, b = grid[i,2], tau1sq = grid[i,1], tau2sq = 1e-6)
if (i %%100 == 0){cat(i,"\t")}
}
# ggplot(df, aes(tau1sq, b, fill= lp)) +
#   geom_tile()
# ggsave("figures/heatmap_wea.png",width=8,height=6)
df[which.max(lp),]
tau1sq_hat <- df[which.max(lp),1]
# plot heatmap
df <- data.frame(tau1sq = grid[,1], b1 = grid[,2], lp = lp)
# ggplot(df, aes(tau1sq, b, fill= lp)) +
#   geom_tile()
# ggsave("figures/heatmap_wea.png",width=8,height=6)
df[which.max(lp),]
sum(is.na(lp))
library(mvtnorm)
####
setwd("/home/mikel/Desktop/Code/SDS383D-Schwob/data")
data <- read.csv("weather.csv",header=T)
y <- data$pressure
# y <- data$temperature
X <- data[,3:4]
n <- length(y)
## Function of Squared exponential covariance function
Exp2Sigma <- function(X, b, tau1sq, tau2sq){
eucDist = as.matrix(dist(X,diag=T,upper=T))
kron.delta = diag(nrow(X))
tau1sq*exp(-.5*(eucDist/b)^2) + tau2sq*kron.delta
}
## Function of Squared exponential covariance function
Exp2Sigma_sep <- function(X, b, tau1sq, tau2sq){
Dist1 = as.matrix(dist(X[,1],diag=T,upper=T))
Dist2 = as.matrix(dist(X[,2],diag=T,upper=T))
kron.delta = diag(nrow=nrow(X))
tau1sq*exp(-.5*((Dist1/as.numeric(b[1]))^2+ (Dist2/as.numeric(b[2]))^2)) + tau2sq*kron.delta
}
# ## Create covariance matrix with Matern function (squared exponential) given distance matrix
# matern.dist <- function(X, b12, tau1sq, tau2sq) {
#   kron.delta = diag(nrow=dim(X)[1])
#   tau1sq*exp(-.5*(X/b)^2) + tau2sq
# }
## Function to calculate the log marginal distribution
logmar <- function(y, X, b, tau1sq, tau2sq){
C <- Exp2Sigma(X, b, tau1sq, tau2sq)
y_mat <- matrix(y,ncol=1)
lp <- -n/2*log(2*pi) - 1/2*log(det(C + sigma2*diag(n))) - 1/2*t(y_mat)%*%solve(C + sigma2*diag(n))%*%y_mat
return(lp)
}
tau2sq <- 1e-6
sigma2 <- 1
## find optimal parameters
tau1sq_seq <- seq(10,200,length.out = 50)
b1_seq <- seq(0.01,5,length.out = 50)
b2_seq <- seq(0.01,5,length.out = 50)
grid <- expand.grid(tau1sq_seq,b1_seq)
lp <- rep(NA,nrow(grid))
for (i in 1:nrow(grid)){
lp[i] <- logmar(y, X, b = grid[i,2], tau1sq = grid[i,1], tau2sq = 1e-6)
if (i %%100 == 0){cat(i,"\t")}
}
# plot heatmap
df <- data.frame(tau1sq = grid[,1], b1 = grid[,2], lp = lp)
# ggplot(df, aes(tau1sq, b, fill= lp)) +
#   geom_tile()
# ggsave("figures/heatmap_wea.png",width=8,height=6)
df[which.max(lp),]
tau1sq_hat <- df[which.max(lp),1]
b_hat <- df[which.max(lp),2:3]
### Use the optimal parameters
n_grid <- 100
x_long <- seq(min(X[,1]), max(X[,1]), length.out = n_grid)
x_lat <- seq(min(X[,2]), max(X[,2]), length.out = n_grid)
X_new <- expand.grid(x_long, x_lat)
tau2sq <- 1e-6
tau1sq <- tau1sq_hat
b <- b_hat
sigma2 <- 1
## Function to calculate C(x,x^*)
C_tilde <- function(X, Xstar, b, tau1sq, tau2sq){
Dist1 = (X[,1] - Xstar[,1])
Dist2 = (X[,2] - Xstar[,2])
tau1sq*exp(-.5*((Dist1/as.numeric(b[1]))^2+ (Dist2/as.numeric(b[2]))^2)) #+ tau2sq*colSums(X == Xstar)
}
C <- Exp2Sigma_sep(X, b, tau1sq, tau2sq)
Cinv <- solve(C + sigma2*diag(n))
fhat <- var <- rep(0,nrow(X_new))
for (i in 1:nrow(X_new)){
Ct <- C_tilde(X, X_new[i,], b, tau1sq, tau2sq)
Cstar <- C_tilde(X_new[i,], X_new[i,], b, tau1sq, tau2sq)
fhat[i] <- Ct%*%Cinv%*%as.matrix(y,ncol=1)
var[i] <- Cstar - Ct%*%Cinv%*%matrix(Ct,ncol=1)
}
df <- data.frame(x=X_new[,1], y=X_new[,2], fhat = fhat, sd = sqrt(var))
# ggplot(df, aes(x, y, fill= fhat)) +
#   geom_tile()
par(mfrow = c(1, 2))
# cols <- heat.colors(100)
image(x_lat, x_long, matrix(fhat, ncol = n_grid), xlab = "Latitude", ylab = "Longitude", col = cols)
points(X[, 2], X[, 1])
image(x_lat, x_long, matrix(sqrt(var), ncol = n_grid), xlab = "Latitude", ylab = "Longitude", col = cols)
points(X[, 2], X[, 1])
cols <- heat.colors(100)
image(x_lat, x_long, matrix(fhat, ncol = n_grid), xlab = "Latitude", ylab = "Longitude", col = cols)
points(X[, 2], X[, 1])
image(x_lat, x_long, matrix(sqrt(var), ncol = n_grid), xlab = "Latitude", ylab = "Longitude", col = cols)
points(X[, 2], X[, 1])
